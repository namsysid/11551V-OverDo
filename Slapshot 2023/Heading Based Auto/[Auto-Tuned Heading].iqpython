{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nLeftMotor = Motor(Ports.PORT8, False)\nRightMotor = Motor(Ports.PORT11, True)\nTouchLedR = Touchled(Ports.PORT9)\nTouchLedL = Touchled(Ports.PORT10)\nBlueDispenser = Motor(Ports.PORT7, False)\nShooting = Motor(Ports.PORT12, False)\n#endregion VEXcode Generated Robot Configuration\nyellowgoal = Event()\nbluegoal = Event()\ncolorDisp = 0\nwhichgoal = 0\n\ndef drivestraight(distance, heading, velocity):\n    RightMotor.set_max_torque(100, PERCENT)\n    LeftMotor.set_max_torque(100, PERCENT)\n    distance_rotation = distance/20*360\n    error = 0\n    output = 0\n\n    LeftMotor.set_position(0, DEGREES)\n    RightMotor.set_position(0, DEGREES)\n\n    while min(LeftMotor.position(DEGREES), RightMotor.position(DEGREES)) < distance_rotation:\n        if TouchLedL.pressing() or TouchLedR.pressing():\n            LeftMotor.stop()\n            RightMotor.stop()\n            break\n\n        else:\n            correction_rotation1 = (heading+360-brain_inertial.heading()) \n            correction_rotation2 = brain_inertial.heading()\n\n            if min(correction_rotation1, correction_rotation2) > 1:\n                if correction_rotation1 < correction_rotation2:\n                    TouchLedL.set_brightness(0)\n                    while correction_rotation1 > 1 and correction_rotation1 < correction_rotation2 and min(LeftMotor.position(DEGREES), RightMotor.position(DEGREES)) < distance_rotation:\n                        TouchLedR.set_brightness(50)\n                        TouchLedR.set_color(Color.ORANGE)\n\n                        LeftMotor.set_velocity(velocity*1.2)\n                        RightMotor.set_velocity(velocity*1)\n                        LeftMotor.spin(FORWARD)\n                        RightMotor.spin(FORWARD)\n\n                        correction_rotation1 = (heading+360-brain_inertial.heading())\n                        correction_rotation2 = brain_inertial.heading()\n\n                    TouchLedR.set_brightness(0)\n                else:\n                    TouchLedR.set_brightness(0)\n                    while correction_rotation2 > 1 and correction_rotation2 < correction_rotation1 and min(LeftMotor.position(DEGREES), RightMotor.position(DEGREES)) < distance_rotation:\n                        TouchLedL.set_brightness(50)\n                        TouchLedL.set_color(Color.ORANGE)\n\n                        RightMotor.set_velocity(velocity*1.2)\n                        LeftMotor.set_velocity(velocity*1)\n                        LeftMotor.spin(FORWARD)\n                        RightMotor.spin(FORWARD)\n\n                        correction_rotation1 = (heading+360-brain_inertial.heading())\n                        correction_rotation2 = brain_inertial.heading()\n\n                    TouchLedL.set_brightness(0)\n\n            else:\n                TouchLedR.set_brightness(100)\n                TouchLedL.set_brightness(100)\n                TouchLedR.set_color(Color.RED)\n                TouchLedL.set_color(Color.RED)\n\n                LeftMotor.set_velocity(velocity)\n                RightMotor.set_velocity(velocity)\n                LeftMotor.spin(FORWARD)\n                RightMotor.spin(FORWARD)\n\n    LeftMotor.stop()\n    RightMotor.stop()\n    return\n     \n\ndef turnonaxis(degree):\n    brain0 = brain_inertial.rotation()\n    degree0 = abs(degree)\n    wantedrotation = brain0+degree\n\n    while brain_inertial.rotation() < wantedrotation:\n        if TouchLedL.pressing() or TouchLedR.pressing():\n            LeftMotor.stop()\n            RightMotor.stop()\n            return\n        else:\n            if (wantedrotation-brain_inertial.rotation()) > 80:\n                LeftMotor.set_velocity(80, PERCENT)\n            else:\n                LeftMotor.set_velocity(30, PERCENT)\n\n            if degree > 0:\n                LeftMotor.spin(FORWARD)\n            else:\n                LeftMotor.spin(REVERSE)\n    \n    LeftMotor.stop()\n    RightMotor.stop()\n    return\n    \n\ndef onevent_yellowgoal_0():\n    global yellowgoal, bluegoal, colorDisp, whichgoal\n    drivestraight(10, 0, 80)\n    turnonaxis(90)\n    return\n\n\ndef onevent_bluegoal_0():\n    global yellowgoal, bluegoal, colorDisp, whichgoal\n\ndef when_started1():\n    global yellowgoal, bluegoal, colorDisp, whichgoal\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(50)\n    LeftMotor.set_stopping(BRAKE)\n    RightMotor.set_stopping(BRAKE)\n\n    \n    TouchLedR.set_color(Color.RED)\n    TouchLedL.set_color(Color.YELLOW)\n    whichgoal = 0\n\n    while True:\n        TouchLedR.set_color(Color.GREEN)\n        if TouchLedR.pressing():\n            if whichgoal == 0:\n                TouchLedR.set_color(Color.GREEN)\n                wait(500, MSEC)\n                yellowgoal.broadcast_and_wait()\n                TouchLedR.set_brightness(100)\n                TouchLedL.set_brightness(100)\n                TouchLedR.set_color(Color.RED)\n                TouchLedL.set_color(Color.BLUE)\n                whichgoal = 1\n                wait(300, MSEC)\n            if whichgoal == 1:\n                TouchLedR.set_color(Color.GREEN)\n                wait(500, MSEC)\n                bluegoal.broadcast_and_wait()\n                TouchLedR.set_brightness(100)\n                TouchLedL.set_brightness(100)\n                TouchLedR.set_color(Color.RED)\n                TouchLedL.set_color(Color.YELLOW)\n                whichgoal = 0\n                wait(300, MSEC)\n        if TouchLedL.pressing():\n            if whichgoal == 1:\n                whichgoal = 0\n                TouchLedL.set_color(Color.YELLOW)\n            else:\n                whichgoal = 1\n                TouchLedL.set_color(Color.BLUE)\n            wait(300, MSEC)\n        wait(20, MSEC)\n\n\n# system event handlers\nyellowgoal(onevent_yellowgoal_0)\nbluegoal(onevent_bluegoal_0)\n# add 15ms delay to make sure events are registered correctly.\nwait(15, MSEC)\n\nwhen_started1()\n","textLanguage":"python","rconfig":[{"port":[8],"name":"LeftMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[11],"name":"RightMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[9],"name":"TouchLedR","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[10],"name":"TouchLedL","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[7],"name":"BlueDispenser","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"Shooting","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.4","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","target":"Physical"}