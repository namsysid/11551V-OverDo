{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nLeftMotor = Motor(Ports.PORT8, False)\nRightMotor = Motor(Ports.PORT11, True)\nTouchLedR = Touchled(Ports.PORT1)\nTouchLedL = Touchled(Ports.PORT10)\nBlueDispenser = Motor(Ports.PORT7, False)\nShooting = Motor(Ports.PORT12, False)\n#endregion VEXcode Generated Robot Configuration\nyellowgoal = Event()\nbluegoal = Event()\ncolorDisp = 0\nwhichgoal = 0\n\n\ndef logStates(tag):\n    print(\"{0} heading:{1} rotation:{2}\".format(tag, brain_inertial.heading(), brain_inertial.rotation()))\n\n\ndef drivestraight(distance, velocity):\n    print(\"#drivestraight {0} / {1}\".format(distance, velocity))\n    brain_inertial.set_heading(0, DEGREES)\n    wait(1, SECONDS)\n    print(\"#drivestraight reset heading {0} / {1}\".format(distance, velocity))\n    logStates('drivestraight')\n \n    RightMotor.set_max_torque(80, PERCENT)\n    LeftMotor.set_max_torque(80, PERCENT)\n    distance_rotation = distance/20*360\n    error = 0\n    output = 0\n\n    LeftMotor.set_position(0, DEGREES)\n    RightMotor.set_position(0, DEGREES)\n\n    while min(abs(LeftMotor.position(DEGREES)), abs(RightMotor.position(DEGREES))) < abs(distance_rotation):\n        if TouchLedL.pressing() or TouchLedR.pressing():\n            LeftMotor.stop()\n            RightMotor.stop()\n            break\n\n        else:\n            correction_rotation1 = (360-brain_inertial.heading()) \n            correction_rotation2 = brain_inertial.heading()\n            if velocity > 0:\n                if min(correction_rotation1, correction_rotation2) > 1:\n                    if correction_rotation1 < correction_rotation2:\n                        TouchLedL.set_brightness(0)\n                        while correction_rotation1 > 1 and correction_rotation1 < correction_rotation2 and min(LeftMotor.position(DEGREES), RightMotor.position(DEGREES)) < distance_rotation and not TouchLedL.pressing() and not TouchLedR.pressing():\n                            logStates('rotationR heading:')\n                            TouchLedR.set_brightness(50)\n                            TouchLedR.set_color(Color.ORANGE)\n\n                            LeftMotor.set_velocity(velocity*1.2)\n                            RightMotor.set_velocity(velocity*0.9)\n                            LeftMotor.spin(FORWARD)\n                            RightMotor.spin(FORWARD)\n\n                            correction_rotation1 = (360-brain_inertial.heading())\n                            correction_rotation2 = brain_inertial.heading()\n\n                        TouchLedR.set_brightness(0)\n                    else:\n                        TouchLedR.set_brightness(0)\n                        while correction_rotation2 > 1 and correction_rotation2 < correction_rotation1 and min(LeftMotor.position(DEGREES), RightMotor.position(DEGREES)) < distance_rotation and not TouchLedL.pressing() and not TouchLedR.pressing():\n                            logStates('rotationL heading:')\n                            TouchLedL.set_brightness(50)\n                            TouchLedL.set_color(Color.ORANGE)\n\n                            RightMotor.set_velocity(velocity*1.2)\n                            LeftMotor.set_velocity(velocity*.9)\n                            LeftMotor.spin(FORWARD)\n                            RightMotor.spin(FORWARD)\n\n                            correction_rotation1 = (360-brain_inertial.heading())\n                            correction_rotation2 = brain_inertial.heading()\n\n                        TouchLedL.set_brightness(0)\n\n                else:\n                    TouchLedR.set_brightness(100)\n                    TouchLedL.set_brightness(100)\n                    TouchLedR.set_color(Color.RED)\n                    TouchLedL.set_color(Color.RED)\n\n                    LeftMotor.set_velocity(velocity)\n                    RightMotor.set_velocity(velocity)\n                    LeftMotor.spin(FORWARD)\n                    RightMotor.spin(FORWARD)\n            else:\n                if min(correction_rotation1, correction_rotation2) > 1.5:\n                    if correction_rotation1 < correction_rotation2:\n                        TouchLedR.set_brightness(0)\n                        while correction_rotation1 > 1.5 and correction_rotation1 < correction_rotation2 and max(LeftMotor.position(DEGREES), RightMotor.position(DEGREES)) > -distance_rotation and not TouchLedL.pressing() and not TouchLedR.pressing():\n                            TouchLedL.set_brightness(50)\n                            TouchLedL.set_color(Color.ORANGE)\n\n                            LeftMotor.set_velocity(velocity*0.9)\n                            RightMotor.set_velocity(velocity*1.2)\n                            LeftMotor.spin(FORWARD)\n                            RightMotor.spin(FORWARD)\n\n                            correction_rotation1 = (360-brain_inertial.heading())\n                            correction_rotation2 = brain_inertial.heading()\n\n                        TouchLedL.set_brightness(0)\n                    else:\n                        TouchLedL.set_brightness(0)\n                        while correction_rotation2 > 1.5 and correction_rotation2 < correction_rotation1 and max(LeftMotor.position(DEGREES), RightMotor.position(DEGREES)) > -distance_rotation and not TouchLedL.pressing() and not TouchLedR.pressing():\n                            TouchLedR.set_brightness(50)\n                            TouchLedR.set_color(Color.ORANGE)\n\n                            RightMotor.set_velocity(velocity*0.9)\n                            LeftMotor.set_velocity(velocity*1.2)\n                            LeftMotor.spin(FORWARD)\n                            RightMotor.spin(FORWARD)\n\n                            correction_rotation1 = (360-brain_inertial.heading())\n                            correction_rotation2 = brain_inertial.heading()\n\n                        TouchLedR.set_brightness(0)\n\n                else:\n                    TouchLedR.set_brightness(100)\n                    TouchLedL.set_brightness(100)\n                    TouchLedR.set_color(Color.RED)\n                    TouchLedL.set_color(Color.RED)\n\n                    LeftMotor.set_velocity(velocity)\n                    RightMotor.set_velocity(velocity)\n                    LeftMotor.spin(FORWARD)\n                    RightMotor.spin(FORWARD)\n\n    LeftMotor.stop()\n    RightMotor.stop()\n\n    while brain_inertial.heading() < 1 or brain_inertial.heading() > 359:\n        if brain_inertial.heading() > 360-brain_inertial.heading():\n            RightMotor.spin(FORWARD)\n        else:\n            LeftMotor.spin(FORWARD)\n    \n    LeftMotor.stop()\n    RightMotor.stop()\n    return\n\n\ndef turnonaxis(wanteddegree):\n    logStates(\"turnonaxis init\")\n    degree = brain_inertial.rotation()+wanteddegree\n\n    if wanteddegree > 0:\n        while brain_inertial.rotation() < degree:\n            logStates(\"turnonaxis wanteddegree>0\")\n            if TouchLedL.pressing() or TouchLedR.pressing():\n                TouchLedL.set_color(Color.PURPLE)\n                LeftMotor.stop()\n                RightMotor.stop()\n                return \n            else:\n                if brain_inertial.rotation() < degree-30:\n                    LeftMotor.set_velocity(80, PERCENT)\n                else:\n                    LeftMotor.set_velocity(20, PERCENT)\n                LeftMotor.spin(FORWARD)\n        LeftMotor.stop()\n        RightMotor.stop()\n        return\n    else:\n        while brain_inertial.rotation() > degree:\n            logStates(\"turnonaxis wanteddegree<0 \")\n            if TouchLedL.pressing() or TouchLedR.pressing():\n                TouchLedL.set_color(Color.PURPLE)\n                LeftMotor.stop()\n                RightMotor.stop()\n                return\n            else:\n                if brain_inertial.rotation() > (degree+30):\n                    LeftMotor.set_velocity(80, PERCENT)\n                else:\n                    LeftMotor.set_velocity(20, PERCENT)\n            LeftMotor.spin(REVERSE)\n        LeftMotor.stop()\n        RightMotor.stop()\n        return\n    \n    \n\ndef onevent_yellowgoal_0():\n    global yellowgoal, bluegoal, colorDisp, whichgoal\n    drivestraight(106.7, 70)\n    turnonaxis(90)\n    drivestraight(30.48, -70)\n    turnonaxis(-90)\n    drivestraight(14, -100)\n    return  \n\ndef shake():\n    for i in range(6):\n        drivestraight(10.16, 90)\n\ndef shoot():\n    for i in range(24):\n        Shooting.set_max_torque(100, PERCENT)\n        Shooting.set_velocity(80,PERCENT)\n        Shooting.spin(FORWARD)\n\ndef onevent_bluegoal_0():\n    global yellowgoal, bluegoal, colorDisp, whichgoal\n    BlueDispenser.spin(FORWARD)\n    drivestraight(68.58, 70)\n    turnonaxis(90)\n    drivestraight(19.5, 50)\n    turnonaxis(-90)\n    drivestraight(30.48, -50)\n    BlueDispenser.spin(REVERSE)\n    wait(5, SECONDS)\n    BlueDispenser.spin(FORWARD)\n    turnonaxis(-10)\n    shake()\n    shoot()\n    \n    \n\n\n    \n\n\n\n\n\ndef when_started1():\n    global yellowgoal, bluegoal, colorDisp, whichgoal\n    LeftMotor.set_stopping(BRAKE)\n    RightMotor.set_stopping(BRAKE)\n    TouchLedR.set_fade(FadeType.FAST)\n    TouchLedL.set_fade(FadeType.FAST)\n\n    TouchLedR.set_color(Color.RED)\n    TouchLedL.set_color(Color.YELLOW)\n    whichgoal = 0\n\n    while True:\n        TouchLedR.set_color(Color.GREEN)\n        if TouchLedR.pressing():\n            TouchLedR.set_color(Color.RED)\n\n            brain_inertial.calibrate()\n            for i in range(25):\n                TouchLedR.set_brightness(100)\n                TouchLedL.set_brightness(100)\n                TouchLedR.set_color(Color.PURPLE)\n                TouchLedL.set_color(Color.PURPLE)\n                wait(100, MSEC)\n                TouchLedR.set_brightness(0)\n                TouchLedL.set_brightness(0)\n                wait(100, MSEC)\n\n            if whichgoal == 0:\n                yellowgoal.broadcast_and_wait()\n                TouchLedR.set_brightness(100)\n                TouchLedL.set_brightness(100)\n                TouchLedR.set_color(Color.GREEN)\n                TouchLedL.set_color(Color.BLUE)\n                whichgoal = 1\n                wait(300, MSEC)\n            elif whichgoal == 1:\n                bluegoal.broadcast_and_wait()\n                TouchLedR.set_brightness(100)\n                TouchLedL.set_brightness(100)\n                TouchLedR.set_color(Color.GREEN)\n                TouchLedL.set_color(Color.YELLOW)\n                whichgoal = 0\n                wait(300, MSEC)\n        if TouchLedL.pressing():\n            if whichgoal == 1:\n                whichgoal = 0\n                TouchLedL.set_color(Color.YELLOW)\n            else:\n                whichgoal = 1\n                TouchLedL.set_color(Color.BLUE)\n            wait(300, MSEC)\n        wait(200, MSEC)\n\n\n# system event handlers\nyellowgoal(onevent_yellowgoal_0)\nbluegoal(onevent_bluegoal_0)\n# add 15ms delay to make sure events are registered correctly.\nwait(15, MSEC)\n\nwhen_started1()\n","textLanguage":"python","rconfig":[{"port":[8],"name":"LeftMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[11],"name":"RightMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[1],"name":"TouchLedR","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[10],"name":"TouchLedL","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[7],"name":"BlueDispenser","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"Shooting","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.4","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","target":"Physical"}